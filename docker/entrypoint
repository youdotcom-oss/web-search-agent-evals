#!/usr/bin/env bun
import { $ } from "bun";
import { MCP_SERVERS } from "/eval/mcp-servers.ts";
import type { McpServerKey } from "/eval/mcp-servers.ts";

/**
 * Docker entrypoint for ACP evaluation containers
 *
 * @remarks
 * Configures MCP servers dynamically based on MCP_TOOL environment variable,
 * then executes the agent-eval-harness capture command with derived paths.
 *
 * **Environment variables:**
 * - `AGENT` - Agent name (claude-code, gemini, droid, codex)
 * - `SEARCH_PROVIDER` - Search provider to use (builtin, you, exa, etc.) or "builtin" for no MCP
 * - `YOU_API_KEY` - API key for You.com MCP server
 * - `OPENAI_API_KEY` - API key for Codex agent
 *
 * **Execution:**
 * - If args provided: Execute args directly
 * - If no args: Build capture command dynamically based on environment
 *
 * @public
 */

const AGENT = process.env.AGENT;
const SEARCH_PROVIDER = (process.env.SEARCH_PROVIDER || "builtin") as McpServerKey | "builtin";
const DATASET = process.env.DATASET || "test"; // test | full

/**
 * Configure Codex CLI with API key
 *
 * @remarks
 * Codex requires authentication via `codex login --with-api-key`.
 * This must run before any Codex commands.
 */
const configureCodex = async (): Promise<void> => {
  if (AGENT !== "codex" || !process.env.OPENAI_API_KEY) {
    return;
  }

  console.log("Configuring Codex CLI with API key...");
  await $`echo ${process.env.OPENAI_API_KEY} | codex login --with-api-key`.quiet();
  console.log("âœ“ Codex CLI configured");
};

/**
 * Configure MCP server for agent via CLI commands
 *
 * @remarks
 * Each agent has its own CLI command format:
 * - Claude: `claude mcp add --transport http <name> <url> --header "KEY: VALUE"`
 * - Gemini: `gemini mcp add --transport http --header "KEY: VALUE" <name> <url>`
 * - Droid: `droid mcp add <name> <url> --type http --header "KEY: VALUE"`
 * - Codex: Uses ~/.codex/config.toml file (no simple CLI)
 *
 * @param agent - Agent name
 * @param tool - MCP tool key from MCP_SERVERS
 */
const configureMcp = async (agent: string, tool: McpServerKey): Promise<void> => {
  console.log(`Configuring MCP for ${agent} with tool ${tool}...`);

  const server = MCP_SERVERS[tool];
  if (!server) {
    console.log(`âš ï¸  Unknown MCP tool: ${tool}`);
    return;
  }

  // Check if API key is available
  const apiKey = server.auth ? process.env[server.auth.envVar] : undefined;
  if (server.auth && !apiKey) {
    console.log(`âš ï¸  Skipping ${agent} MCP: missing ${server.auth.envVar}`);
    return;
  }

  try {
    switch (agent) {
      case "claude-code": {
        await $`claude mcp add --transport http ${server.name} ${server.url} --header "Authorization: Bearer ${apiKey}"`.quiet();
        console.log("âœ“ Claude Code MCP server added via CLI");
        break;
      }

      case "gemini": {
        await $`gemini mcp add --transport http --header "Authorization: Bearer ${apiKey}" ${server.name} ${server.url}`.quiet();
        console.log("âœ“ Gemini MCP server added via CLI");
        break;
      }

      case "droid": {
        await $`droid mcp add ${server.name} ${server.url} --type http --header "Authorization: Bearer ${apiKey}"`.quiet();
        console.log("âœ“ Droid MCP server added via CLI");
        break;
      }

      case "codex": {
        // Codex uses config file instead of CLI
        const configDir = `${process.env.HOME}/.codex`;
        await $`mkdir -p ${configDir}`.quiet();

        const config = `[mcp_servers.${server.name}]
url = "${server.url}"
bearer_token_env_var = "${server.auth?.envVar}"
`;
        await Bun.write(`${configDir}/config.toml`, config);
        console.log("âœ“ Codex MCP server configured in ~/.codex/config.toml");
        break;
      }

      default:
        console.log(`âš ï¸  Unknown agent: ${agent}`);
    }
  } catch (error) {
    console.error(`âš ï¸  Failed to configure MCP for ${agent}:`, error);
  }
};

/**
 * Detect if running in trials mode
 *
 * @remarks
 * Checks if 'trials' command is present in Bun.argv to determine execution mode.
 * Trials mode outputs to dated folders: data/results/trials/YYYY-MM-DD/{agent}/
 *
 * @returns True if trials mode detected
 */
const isTrialsMode = (): boolean => {
  return Bun.argv.some(arg => arg.includes('trials'));
};

/**
 * Build capture command arguments based on environment
 *
 * @remarks
 * Derives:
 * - Prompt file based on DATASET and SEARCH_PROVIDER (e.g., test.jsonl, full-mcp.jsonl)
 * - Schema file (always base schema, no -mcp suffix)
 * - Output file (versioned: test-runs/, runs/YYYY-MM-DD/, or trials/YYYY-MM-DD/)
 * - Grader flag (only for non-builtin modes)
 * - Timeout flag (agent-specific: claude-code 90s, codex 180s)
 *
 * @returns Command arguments array
 */
const buildCaptureCommand = async (): Promise<string[]> => {
  if (!AGENT) {
    throw new Error("AGENT environment variable is required");
  }

  // Derive prompt file based on DATASET and search provider mode
  const promptFile = SEARCH_PROVIDER === "builtin"
    ? `/eval/data/prompts/${DATASET}/prompts.jsonl`
    : `/eval/data/prompts/${DATASET}/prompts-${SEARCH_PROVIDER}.jsonl`;

  // Schema file: Always use base schema (no -mcp suffix)
  const schemaFile = `/eval/agent-schemas/${AGENT}.json`;

  // Output file path based on execution mode
  let outputFile: string;

  if (isTrialsMode()) {
    // Trials mode: output to trials/YYYY-MM-DD/{agent}/ (same structure as runs)
    const runDate = new Date().toISOString().split('T')[0];
    const outputDir = `/eval/data/results/trials/${runDate}/${AGENT}`;
    await $`mkdir -p ${outputDir}`.quiet();

    // Extract trial type from environment variable (default/capability/regression)
    const trialType = process.env.TRIAL_TYPE || 'default';
    const typeSuffix = trialType === 'default' ? '' : `-${trialType}`;

    outputFile = `${outputDir}/${SEARCH_PROVIDER}${typeSuffix}.jsonl`;
    console.log(`ðŸ“Š Trials mode detected`);
    console.log(`   Trial type: ${trialType}`);
    console.log(`   Output: ${outputFile}`);
  } else if (DATASET === "test") {
    // Test results: test-runs directory
    const outputDir = `/eval/data/results/test-runs/${AGENT}`;
    await $`mkdir -p ${outputDir}`.quiet();
    outputFile = `${outputDir}/${SEARCH_PROVIDER}.jsonl`;
  } else {
    // Full results: dated directory (use current date)
    const runDate = new Date().toISOString().split('T')[0];
    const outputDir = `/eval/data/results/runs/${runDate}/${AGENT}`;
    await $`mkdir -p ${outputDir}`.quiet();
    outputFile = `${outputDir}/${SEARCH_PROVIDER}.jsonl`;
  }

  // Build command array
  const cmd = ["bunx", "@plaited/agent-eval-harness", "capture", promptFile, "--schema", schemaFile];

  // Add grader for all evaluations (both builtin and MCP)
  cmd.push("--grader", "/eval/scripts/inline-grader.ts");

  cmd.push("--cwd", "/workspace");

  // Add timeout (180 seconds for all agents)
  cmd.push("--timeout", "180000");

  cmd.push("-o", outputFile, "--progress");

  return cmd;
};

/**
 * Main entrypoint logic
 *
 * @remarks
 * 1. Configure Codex if needed
 * 2. Configure MCP if SEARCH_PROVIDER is set and not "builtin"
 * 3. If args provided: execute them directly
 * 4. If no args: build and execute capture command
 */
const main = async (): Promise<void> => {
  // Configure Codex CLI
  await configureCodex();

  // Configure MCP if needed
  if (SEARCH_PROVIDER !== "builtin" && AGENT) {
    await configureMcp(AGENT, SEARCH_PROVIDER as McpServerKey);
  }

  // If arguments provided, execute them directly
  if (process.argv.length > 2) {
    const args = process.argv.slice(2);
    await $`${args}`.quiet(false);
    process.exit(0);
  }

  // Build and execute capture command
  const cmd = await buildCaptureCommand();

  console.log("Running: bunx @plaited/agent-eval-harness capture", cmd[3]);
  console.log(`  Schema: ${cmd[5]}`);
  console.log(`  Output: ${cmd[cmd.length - 2]}`);
  console.log(`  Search Provider: ${SEARCH_PROVIDER}`);
  console.log("");
  console.log("Executing command:");
  cmd.forEach((arg) => console.log(`  ${arg}`));
  console.log("");

  await $`${cmd}`.quiet(false);
};

// Run main and handle errors
main().catch((error) => {
  console.error("Entrypoint failed:", error);
  process.exit(1);
});
