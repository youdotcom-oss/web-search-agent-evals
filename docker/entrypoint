#!/usr/bin/env bun
import { $ } from "bun";
import { MCP_SERVERS } from "/eval/mcp-servers.ts";
import type { McpServerKey } from "/eval/mcp-servers.ts";

/**
 * Docker entrypoint for ACP evaluation containers
 *
 * @remarks
 * Configures MCP servers dynamically based on SEARCH_PROVIDER environment variable,
 * then executes the agent-eval-harness capture command with derived paths.
 *
 * **Environment variables:**
 * - `AGENT` - Agent name (claude-code, gemini, droid, codex)
 * - `SEARCH_PROVIDER` - Search provider to use (builtin, you, exa, etc.)
 * - `PROMPT_CONCURRENCY` - Number of prompts to run in parallel (optional, enables workspace isolation)
 * - `PROMPT_COUNT` - If set, sample this many prompts randomly from the full dataset
 * - `YDC_API_KEY` - API key for You.com MCP server
 * - `OPENAI_API_KEY` - API key for Codex agent
 *
 * **Execution:**
 * - If args provided: Execute args directly
 * - If no args: Build capture command dynamically based on environment
 *
 * @public
 */

const AGENT = process.env.AGENT;
const SEARCH_PROVIDER = (process.env.SEARCH_PROVIDER || "builtin") as McpServerKey | "builtin";
const PROMPT_CONCURRENCY = process.env.PROMPT_CONCURRENCY ? Number.parseInt(process.env.PROMPT_CONCURRENCY, 10) : undefined;
const PROMPT_COUNT = process.env.PROMPT_COUNT ? Number.parseInt(process.env.PROMPT_COUNT, 10) : undefined;

/**
 * Configure Codex CLI with API key
 *
 * @remarks
 * Codex requires authentication via `codex login --with-api-key`.
 * This must run before any Codex commands.
 */
const configureCodex = async (): Promise<void> => {
  if (AGENT !== "codex" || !process.env.OPENAI_API_KEY) {
    return;
  }

  console.log("Configuring Codex CLI with API key...");
  await $`echo ${process.env.OPENAI_API_KEY} | codex login --with-api-key`.quiet();
  console.log("‚úì Codex CLI configured");
};

/**
 * Configure MCP server for agent via CLI commands
 *
 * @remarks
 * Each agent has its own CLI command format:
 * - Claude: `claude mcp add --transport http <name> <url> --header "KEY: VALUE"`
 * - Gemini: `gemini mcp add --transport http --header "KEY: VALUE" <name> <url>`
 * - Droid: `droid mcp add <name> <url> --type http --header "KEY: VALUE"`
 * - Codex: Uses ~/.codex/config.toml file (no simple CLI)
 *
 * @param agent - Agent name
 * @param tool - MCP tool key from MCP_SERVERS
 */
const configureMcp = async (agent: string, tool: McpServerKey): Promise<void> => {
  console.log(`Configuring MCP for ${agent} with tool ${tool}...`);

  const server = MCP_SERVERS[tool];
  if (!server) {
    console.log(`‚ö†Ô∏è  Unknown MCP tool: ${tool}`);
    return;
  }

  // Check if API key is available
  const apiKey = server.auth ? process.env[server.auth.envVar] : undefined;
  if (server.auth && !apiKey) {
    console.log(`‚ö†Ô∏è  Skipping ${agent} MCP: missing ${server.auth.envVar}`);
    return;
  }

  try {
    switch (agent) {
      case "claude-code": {
        await $`claude mcp add --transport http ${server.name} ${server.url} --header "Authorization: Bearer ${apiKey}"`.quiet();
        console.log("‚úì Claude Code MCP server added via CLI");
        break;
      }

      case "gemini": {
        await $`gemini mcp add --transport http --header "Authorization: Bearer ${apiKey}" ${server.name} ${server.url}`.quiet();
        console.log("‚úì Gemini MCP server added via CLI");
        break;
      }

      case "droid": {
        await $`droid mcp add ${server.name} ${server.url} --type http --header "Authorization: Bearer ${apiKey}"`.quiet();
        console.log("‚úì Droid MCP server added via CLI");
        break;
      }

      case "codex": {
        // Codex uses config file instead of CLI
        const home = process.env.HOME;
        if (!home) throw new Error("HOME environment variable is not set");
        const configDir = `${home}/.codex`;
        await $`mkdir -p ${configDir}`.quiet();

        const config = `[mcp_servers.${server.name}]
url = "${server.url}"
bearer_token_env_var = "${server.auth?.envVar}"
`;
        await Bun.write(`${configDir}/config.toml`, config);
        console.log("‚úì Codex MCP server configured in ~/.codex/config.toml");
        break;
      }

      default:
        console.log(`‚ö†Ô∏è  Unknown agent: ${agent}`);
    }
  } catch (error) {
    console.error(`‚ö†Ô∏è  Failed to configure MCP for ${agent}:`, error);
  }
};

/**
 * Build trials command arguments based on environment
 *
 * @remarks
 * Derives:
 * - Prompt file based on SEARCH_PROVIDER (always uses full dataset)
 * - Schema file (always base schema, no -mcp suffix)
 * - Output file: /eval/data/results/YYYY-MM-DD/{agent}/{provider}.jsonl
 * - Applies PROMPT_COUNT sampling if set (shuffles full prompts, takes N)
 *
 * @returns Command arguments array
 */
const buildTrialsCommand = async (): Promise<string[]> => {
  if (!AGENT) {
    throw new Error("AGENT environment variable is required");
  }

  // Derive prompt file based on search provider (always full dataset)
  let promptFile = SEARCH_PROVIDER === "builtin"
    ? `/eval/data/prompts/prompts.jsonl`
    : `/eval/data/prompts/prompts-${SEARCH_PROVIDER}.jsonl`;

  // If PROMPT_COUNT is set, shuffle and sample N prompts into a temp file
  if (PROMPT_COUNT) {
    const fullText = await Bun.file(promptFile).text();
    const prompts = fullText.trim().split("\n").map((l) => JSON.parse(l));

    // Fisher-Yates shuffle: O(n), every permutation equally likely.
    // Works backwards ‚Äî at each i, swaps with a random j in [0, i].
    for (let i = prompts.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      ;[prompts[i], prompts[j]] = [prompts[j]!, prompts[i]!];
    }

    const sampled = prompts.slice(0, PROMPT_COUNT);
    const tmpFile = `/tmp/sampled-${SEARCH_PROVIDER}-${Date.now()}.jsonl`;
    await Bun.write(tmpFile, sampled.map((p) => JSON.stringify(p)).join("\n"));
    promptFile = tmpFile;
    console.log(`üé≤ Sampling ${PROMPT_COUNT} prompts from full dataset ‚Üí ${tmpFile}`);
  }

  // Schema file: Always use base schema (no -mcp suffix)
  const schemaFile = `/eval/agent-schemas/${AGENT}.json`;

  // Output path: flat dated structure
  const runDate = new Date().toISOString().split("T")[0];
  const trialType = process.env.TRIAL_TYPE || "default";
  const typeSuffix = trialType === "default" ? "" : `-${trialType}`;
  const outputDir = `/eval/data/results/${runDate}/${AGENT}`;
  await $`mkdir -p ${outputDir}`.quiet();
  const outputFile = `${outputDir}/${SEARCH_PROVIDER}${typeSuffix}.jsonl`;

  console.log(`üìä Trials mode`);
  console.log(`   Trial type: ${trialType}`);
  console.log(`   Output: ${outputFile}`);

  // Build command array using harness 'trials' command
  const cmd = ["bunx", "@plaited/agent-eval-harness", "trials", promptFile, "--schema", schemaFile];

  // Add grader for all evaluations (both builtin and MCP)
  cmd.push("--grader", "/eval/scripts/inline-grader.ts");

  cmd.push("--cwd", "/workspace");

  // Extract k value from TRIAL_TYPE preset or use default (5)
  const kValues: Record<string, number> = { default: 5, capability: 10, regression: 3 };
  const k = kValues[trialType] ?? 5;
  cmd.push("-k", k.toString());

  // Add prompt concurrency and workspace isolation if specified
  if (PROMPT_CONCURRENCY && PROMPT_CONCURRENCY > 1) {
    cmd.push("-j", PROMPT_CONCURRENCY.toString());
    cmd.push("--workspace-dir", "/workspace/runs");
    console.log(`üîÄ Prompt parallelization enabled (${PROMPT_CONCURRENCY} concurrent prompts)`);
  }

  cmd.push("-o", outputFile, "--progress");

  return cmd;
};

/**
 * Main entrypoint logic
 *
 * @remarks
 * 1. Configure Codex if needed
 * 2. Configure MCP if SEARCH_PROVIDER is set and not "builtin"
 * 3. If args provided: execute them directly
 * 4. If no args: build and execute trials command
 */
const main = async (): Promise<void> => {
  // Configure Codex CLI
  await configureCodex();

  // Configure search provider
  if (SEARCH_PROVIDER !== "builtin" && AGENT) {
    await configureMcp(AGENT, SEARCH_PROVIDER as McpServerKey);
  }

  // If arguments provided, execute them directly
  if (process.argv.length > 2) {
    const args = process.argv.slice(2);
    await $`${args}`.quiet(false);
    process.exit(0);
  }

  // Build and execute trials command
  const cmd = await buildTrialsCommand();

  const trialsCmdIdx = cmd.indexOf("trials");
  const schemaIdx = cmd.indexOf("--schema");
  const outputIdx = cmd.indexOf("-o");
  console.log("Running: bunx @plaited/agent-eval-harness trials", trialsCmdIdx !== -1 ? cmd[trialsCmdIdx + 1] : "?");
  console.log(`  Schema: ${schemaIdx !== -1 ? cmd[schemaIdx + 1] : "?"}`);
  console.log(`  Output: ${outputIdx !== -1 ? cmd[outputIdx + 1] : "?"}`);
  console.log(`  Search Provider: ${SEARCH_PROVIDER}`);
  console.log("");
  console.log("Executing command:");
  cmd.forEach((arg) => console.log(`  ${arg}`));
  console.log("");

  try {
    await $`${cmd}`.quiet(false);

    // Cleanup workspace directories if prompt concurrency was used
    if (PROMPT_CONCURRENCY && PROMPT_CONCURRENCY > 1) {
      console.log("\nüßπ Cleaning up workspace directories...");
      await $`rm -rf /workspace/runs`.quiet();
      console.log("‚úì Workspace cleaned");
    }
  } catch (error) {
    // Still cleanup on error
    if (PROMPT_CONCURRENCY && PROMPT_CONCURRENCY > 1) {
      await $`rm -rf /workspace/runs`.quiet();
    }
    throw error;
  }
};

// Run main and handle errors
main().catch((error) => {
  console.error("Entrypoint failed:", error);
  process.exit(1);
});
